<pre class='metadata'>
Title: Removing exception_ptr from the Receiver Concepts
H1: <code>Removing exception_ptr from the Receiver Concepts</code>
Shortname: D2532
Revision: 0
Status: D
Group: WG21
Audience: LEWG
Editor: Eric Niebler, eric.niebler@gmail.com
URL: https://wg21.link/P2532
!Source: <a href="https://github.com/brycelelbach/wg21_p2300_std_execution/blob/main/receiver_redesign.bs">GitHub</a>
Issue Tracking: GitHub https://github.com/brycelelbach/wg21_p2300_std_execution/issues
Metadata Order: Editor, This Version, Source, Issue Tracking, Project, Audience
Markup Shorthands: markdown yes
Toggle Diffs: no
No Abstract: yes
Default Biblio Display: direct
</pre>

<style>
pre {
  margin-top: 0px;
  margin-bottom: 0px;
}
table, th, tr, td {
  border: 2px solid black !important;
}
@media (prefers-color-scheme: dark) {
  table, th, tr, td {
    border: 2px solid white !important;
  }
}
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}
.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
math, span.math {
  font-family: serif;
  font-style: italic;
}
ul {
  list-style-type: "— ";
}
blockquote {
  counter-reset: paragraph;
}
div.numbered, div.newnumbered {
  margin-left: 2em;
  margin-top: 1em;
  margin-bottom: 1em;
}
div.numbered:before, div.newnumbered:before {
  position: absolute;
  margin-left: -2em;
  display-style: block;
}
div.numbered:before {
  content: counter(paragraph);
  counter-increment: paragraph;
}
div.newnumbered:before {
  content: "�";
}
div.numbered ul, div.newnumbered ul {
  counter-reset: list_item;
}
div.numbered li, div.newnumbered li {
  margin-left: 3em;
}
div.numbered li:before, div.newnumbered li:before {
  position: absolute;
  margin-left: -4.8em;
  display-style: block;
}
div.numbered li:before {
  content: "(" counter(paragraph) "." counter(list_item) ")";
  counter-increment: list_item;
}
div.newnumbered li:before {
  content: "(�." counter(list_item) ")";
  counter-increment: list_item;
}
</style>

# Introduction # {#intro}

This paper proposes a refactorization of the receiver concepts of [[P2300R4]] to
address concerns raised by LEWG during its design review related to the
requirement of an error channel that accepts `exception_ptr`. The change to
`receiver_of` proposed herein enables a corresponding change to the `sender_to`
concept that strengthens type checking and removes some need to constrain
customizations of the `connect` customization point.

## Motivation ## {#motivation}

In [[P2300R4]], the receiver concepts are currently expressed as follows:

```c++
    template <class T, class E = exception_ptr>
    concept receiver =
      move_constructible<remove_cvref_t<T>> &&
      constructible_from<remove_cvref_t<T>, T> &&
      requires(remove_cvref_t<T>&& t, E&& e) {
        { execution::set_stopped(std::move(t)) } noexcept;
        { execution::set_error(std::move(t), (E&&) e) } noexcept;
      };

    template<class T, class... An>
    concept receiver_of =
      receiver<T> &&
      requires(remove_cvref_t<T>&& t, An&&... an) {
        execution::set_value(std::move(t), (An&&) an...);
      };
```

During the design review of P2300, LEWG raised the following concerns about the
form of these concepts:

1. Since `set_value` is permitted to be potentially throwing, and since the
    receiver type is not known when a sender is asked to compute its completion
    signatures, most senders will need to pessimistically report that they can
    complete exceptionally, when that may in fact not be true. This may cause the
    instantiation of expensive error handling code that is effectively dead.

2. No receiver `R` can satisfy the `receiver<R>` or `receiver_of<R, As...>`
    concepts without providing an error channel for `exception_ptr`. This has the
    following problems:

    * `exception_ptr` is a relatively heavy-weight error type, not unlike a
        `shared_ptr`. Requiring the presence of this channel is likely to cause
        needless code generation.

    * It makes it questionable whether any of P2300 can be reasonably expected
        to work in freestanding environments, which often lack exception
        handling support.

Although the design of P2300 is sound, LEWG nevertheless wanted an investigation
into these issues and a recommendation to be made.

This paper makes a recommendation to change the receiver concepts to address
these concerns.

## Design Summary ## {#design-summary}

This paper proposes to make the following changes, summarized here without
commentary. Commentary is provided below.

* Remove the default implementation of the `get_env` receiver query.

* The `receiver_of` concept takes a receiver and an instance of the
    `completion_signatures<>` class template.

* A receiver's customization of `set_value` is required to be `noexcept`.

* The `sender_to<Sndr, Rcvr>` concept requires `Rcvr` to accept all of `Sndr`'s
    completions.

* `connect(sndr, rcvr)` also requires `rcvr` to accept all of `sndr`'s completions.

* `get_completion_signatures` is required to return an instantiation of the
    `completion_signatures` class template; the `value_types_of_t` and
    `error_types_of_t` template aliases remain unchanged.

* The `make_completion_signatures` design is slightly tweaked to be more general.

## Design Rationale ## {#design-rationale}

The author believes these are all reasonable adjustments to the design of P2300,
but one may wonder why they were not considered before now.

The fourth revision of P2300 brought with it some notable changes, the two most
significant of which are:

1. Support for dependently-typed senders, where a sender's completions can
    depend on information that isn't known independently of the execution
    environment within which the sender will be initiated. For instance,
    a `get_scheduler()` sender which queries the receiver for the current
    scheduler and then sends it through the value channel, cannot possibly
    know the type of the scheduler it will send until it has been connected
    to a receiver.

2. Dropping of support for "untyped" senders, which do not declare their
    completion signatures. Untyped senders were supported because of the lack
    of dependently-typed senders, which ceased to be an issue with R4. At the
    direction of LEWG, "untyped" senders were dropped, greatly simplifying
    the design.

Taken together, these two changes open up a huge piece of the design space. The
implication is that <b>a sender is <i>always</i> able to provide its completion
signatures.</b> This is new, and P2300R4 is not taking advantage of this extra
type information.

The author realized that the extra type information can be leveraged to
accommodate LEWGs requests regarding the receiver interface, while at the same
time simplifying uses of `std::execution` by permitting the library to take on
more of the type checking burden.

The `sender_to` concept, which checks whether a sender and a receiver can be
connected, now has perfect information: it can ask the receiver for the execution
environment; it can ask the sender how it will complete when initiated in that
environment; and it can ask the receiver if it is capable of receiving all of
the sender's possible completions. This was not possible before R4.

Below we look at each of the changes suggested in the summary and explain its
rationale in light of the extra information now available to the type system.

# Design Details # {#design-details}

## Remove the default implementation of the `get_env` receiver query. ## {#no-get-env-default}

The presence of a customization of `get_env` becomes the distinguishing feature
of receivers. A "receiver" no longer needs to provide any completion channels at
all to be considered a receiver, only `get_env`.

## The `receiver_of` concept takes a receiver and an instance of the `completion_signatures<>` class template. ## {#receiver-of-completion-signatures}

The `receiver_of` concept, rather than accepting a receiver and some value
types, is changed to take a receiver and an instance of the
`completion_signatures<>` class template. A sender uses
`completion_signatures<>` to describe the signals with which it completes. The
`receiver_of` concept ensures that a particular receiver is capable of receiving
those signals.

Notably, if a sender only sends a value (i.e., can never send an error or a
stopped signal), then a receiver need only provide a value channel to be
compatible with it.

## A receiver's customization of `set_value` is required to be `noexcept`. ## {#noexcept-set-value}

This makes it possible for many senders to become "no-fail"; that is, they
cannot complete with an error. `just(1)`, for instance, will only ever
successfully send an integer through the value channel. An adaptor such as
`then(sndr, fun)` can check whether `fun` can ever exit exceptionally when
called with all the sets of values that `sndr` may complete with. If so, the
`then` sender must add `set_error_t(exception_ptr)` to its list of completions.
Otherwise, it need not.

## The `sender_to<Sndr, Rcvr>` concept requires `Rcvr` to accept all of `Sndr`'s completions. ## {#sender-to-requirements}

The `sender_to` concept, which checks whether a sender and a receiver can be
connected, now enforces that the sender's completion signatures can in fact be
handled by the receiver. Previously, it only checked that `connect(sndr, rcvr)`
was well-formed, relying on sender authors to properly constrain their `connect`
customizations.

## `connect(sndr, rcvr)` also requires `rcvr` to accept all of `sndr`'s completions. ## {#connect-requirements}

For good measure, the `connect` customization point also checks whether a
receiver can receive all of the sender's possible completions before trying to
dispatch via `tag_invoke` to a `connect` customization. This often entirely
frees sender authors from having to constrain their `connect` customizations at
all. It is enough to customize `get_completion_signatures`, and the type
checking is done automatically.

Strictly speaking, with this change, the change to `sender_to` is unnecessary.
The change to `sender_to` results in better diagnostics, in the author's
experience.

## `get_completion_signatures` is required to return an instantiation of the `completion_signatures` class template. ## {#get-completion-signatures}

`get_completion_signatures` was added in R4 in response to feedback that
authoring sender traits was too difficult/arcane. Rather than defining a struct
with `template template` aliases, a user can simply declare a sender's
completions as:

```c++
execution::completion_signatures<
  execution::set_value_t(int),
  execution::set_error_t(std::exception_ptr),
  execution::set_stopped_t()>
```

In R4, `completion_signatures` generated the `template template` aliases for
you. The proposed change is to take it further and *require*
`get_completion_signatures` to return an instance of the `completion_signatures`
class template. With this change, the last vestige of the old sender traits
design with its unloved `temlate template` alias interface is swept away.
`completion_signatures` entirely replaces sender traits, further simplifying the
design.

The `sender` concept enforces the new requirement.

## The `value_types_of_t` and `error_types_of_t` template aliases remain. ## {#sender-traits-aliases}

It can still be helpful sometimes to *consume* the old `template template`, say,
for generating a variant of the tuples of all the sets of a sender's value
types. For that reason, the alias templates `value_types_of_t` and
`error_types_of_t` retain the same interface and semantic as before. For
instance, generating the variant of tuples of value types, you would use the
following:

  ```c++
  execution::value_types_of_t<
    Sndr,
    Env,
    std::tuple,
    std::variant>;
  ```

Additionally, these two alias joined by a `sends_stopped<Sndr, Env>` Boolean
variable template to complete the set.

## The `make_completion_signatures` design is slightly tweaked to be more general. ## {#make-completion-signatures}

In the proposed design, `completion_signatures` plays a much larger role.
Accordingly, the job of specifying the completion signatures of custom sender
adaptors also becomes more important, necessitating better tools. The
`make_completion_signatures`, new to R4, narrowly misses being that better tool.

In R4, `make_completion_signatures` has the following interface:

    <pre highlight="c++">
    template &lt;
      execution::sender Sndr,
      class Env = execution::no_env,
      class OtherSigs = execution::completion_signatures&lt;>,
      template &lt;class...> class SetValue = <i>default-set-value</i>,
      template &lt;class> class SetError = <i>default-set-error</i>,
      bool SendsStopped = execution::completion_signatures_of_t&lt;Sndr, Env>::sends_stopped>
        requires sender&lt;Sndr, Env>
    using make_completion_signatures =
      execution::completion_signatures&lt;/* see below */>;
    </pre>

In the R4 design, `SetValue` and `SetError` are alias templates, instantiations
of which are required to name function types whose return types are
`excecution::set_value_t` and `execution::set_error_t`, respectively. This is
overly-restrictive. The problems with it are:

1. It is not possible to map one kind of completion into a different kind. For
    instance, the `upon_error(sndr, fun)` maps error completions into value
    completions.

2. It is not possible to map a single completion signature into multiple
    different completions. For instance, the `let_value(sndr, fun)` sender
    adaptor needs to map a set of `sndr`'s value types into the set of
    completions of whatever sender that is returned from `fun(values...)`, which
    is likely more than one.

In addition, the final Boolean `SendsStopped` parameter merely controls whether
or not the completion `execution::set_stopped_t()` should be added to the
resulting list of completion signatures. This doesn't help a sender adaptor
such as `let_stopped(sndr, fun)`, which needs to transform a stopped signal
into the set of completions of the sender that `fun()` returns.

This design proposes to change the three final template arguments as follows:

* <u><b>`template <class...> class SetValue`:</b></u> Instantiations of this alias
    template must name an instantiation of the `completion_signatures` class
    template.

* <u><b>`template <class> class SetError`:</b></u> Instantiations of this alias
    template must name an instantiation of the `completion_signatures` class
    template.

* <u><b>`class SetStopped`:</b></u> Must name an instantiation of the
    `completion_signatures` class template. If the sender `Sndr` can complete
    with `set_stopped`, then these signatures are included in the resulting list
    of completions. Otherwise, this template parameter is ignored.

The semantics of `make_completion_signatures` is likewise simplified: The three
template arguments, `SetValue`, `SetError`, and `SetStopped`, are used to map
each of a sender's completions into a list of completions which are all
concatenated together, along with any additional signatures specified by the
`OtherSigs` list, and made unique.

# Considerations # {#considerations}

## Implications of `noexcept` `set_value` ## {#nothrow-set-value}

The role of `execution::set_value` is to execute a continuation on the success
of the predecessor. A continuation is arbitrary code, and surely arbitrary code
can exit exceptionally, so how can we require `execution::set_value` to be
`noexcept`?

The answer has two parts:

1. `execution::set_value` always has the option of accepting arguments by
    forwarding reference and executing any potentially throwing operations
    within a `try`/`catch` block, routing any exceptions to
    `set_error(std::exception_ptr)`.

2. A sender knows what types it will send and with what value category. The
    `sender_to` concept checks that none of the `set_value` expression(s) it
    will execute are potentially throwing. This doesn't necessitate that all
    receivers accept all arguments by forwarding reference, however. For
    instance, if a sender knows it will pass an rvalue `std::string` to the
    receiver's `set_value`, and if the sender is connected to a receiver whose
    `set_value` takes a `std::string` by value, that will type-check. The
    `sender_to` concept will essentially be enforcing this constraint:

        <pre highlight="c++">
        requires (Receiver rcvr) {
          { execution::set_value(std::move(rcvr), std::string()) } noexcept;
        }
        </pre>

        Since `std::string`'s move constructor is `noexcept`, this constraint
        is satisfied regardless of whether `rcvr`'s `set_value` customization
        accepts the string by value or by reference.

## Diagnostics ## {#diagnostics}

On the whole, the authors of P2300 feel that this design change is the right one
to make to meet LEWG's requirements. It comes with one drawback, however: The
satisfaction checking of the `receiver_of` concept, which must now check against
a set of signatures specified in a type-list, now requires metaprogramming in
addition to `requires` clauses. As a result, diagnostics can suffer.

During the implementation experience, the author was able to surface a
relatively suscinct and accurate error for, say, the lack of a particular
completion channel on a receiver, by employing several tricks. While regrettable
that such tricks are required, we do not feel that the issue of mediocre
diagnostics is dire enough to offset the many advantages of the design presented
here.

In addition, the author has discovered a way that an implementation may choose
to extend the `connect` customization point in a way that permits users to
bypass the constraint checking entirely, thus generating a deep instantiation
backtrace that often greatly assists the debugging of custom
sender/receiver-based algorithms. This mechanism can be enshrined in the standard
as "recommended practice."

# Open questions # {#open-questions}

## Weasel wording for `-fno-exceptions` ## {#fno-exceptions}

We may need to add some weasel wording to the effect that:

> ... if an implementation is able to deduce that all of its operations are not
> potentially throwing, a conforming implementation of the algorithms in
> &lt;section> may omit `set_error_t(exception_ptr)` from any sender's list of
> completion signatures.

If an implementation doesn't support exceptions, e.g., if the user is compiling
with `-fno-exceptions`, it can safely assume that an expression `expr` is not
going to exit exceptionally regardless of the value of `noexcept(expr)`. An
implementation shouldn't be required to report that it can complete with an
exception in that case.

## Error channel of allocating algorithms ## {#allocations}

An interesting question is what to do on freestanding implementations for those
algorithms that necessarily must allocate. Those algorithms, as P2300 stands
today, will always have a `set_error_t(exception_ptr)` completion signature. The
possibilities I see are:

* Permit implementations to omit the exceptional completion signature when it
    knows allocations can't fail with an exception (see above),

* Replace the exceptional completion signature with
    `set_error_t(std::error_code)`, and call the receiver with
    `std::make_error_code(std::errc::not_enough_memory)` on allocation failure.

* Replace the exceptional completion signature with
    `set_error_t(std::bad_alloc)`; that is, pass an instance of the
    `std::bad_alloc` exception type through the error channel by value. (From
    what the author can infer, freestanding implementations are required to
    provide the `std::bad_alloc` type even when actually throwing exceptions is
    not supported.)

# Implementation experience # {#implementation-experience}

The design described above has been implemented in a branch of the reference
implementation which can be found in the following GitHub pull request:
https://github.com/brycelelbach/wg21_p2300_std_execution/pull/410.

The change, while somewhat disruptive to the reference implementation itself,
had the benefits described above; namely:

* Stricter type-checking "for free". Sender authors need only report the
    completion signatures, and the concepts and customization points of the
    library do all the heavy lifting to make sure the capabilities of receivers
    match the requirements of the senders.

* More "no-fail" senders. Many fewer of the senders need an error channel at
    all, and the ones that do generally need it only conditionally, when working
    with potentially-thrwoing callables or types whose special operations can
    throw. Only those few senders that must dynamically allocate state necessarily
    need a `set_error_t(exception_ptr)` channel, and we may even choose to change
    those to use something like `set_error_t(bad_alloc)` instead.

* No required `set_error_t(exception_ptr)` or `set_stopped_t()` channels at all.

In addition, in the author's opinion, the reference implementation got
significantly *simpler* for the change, and the pull request removes more lines
than it adds, while adding functionality at the same time.

# Proposed wording # {#proposed-wording}

The following changes are relative to [[P2300R4]].

## Header `<execution>` synopsis

In [exec.syn], apply the following changes:

    <pre highlight="c++">
    namespace std::execution {
      // [exec.recv], receivers
      template &lt;class T<del>, class E = exception_ptr</del>>
        concept receiver = <i>see-below</i>;

      template &lt;class T, <del>class... An</del><ins>class Completions</ins>>
        concept receiver_of = <i>see-below</i>;

      ...
      <del>
      template&lt;class S>
         concept <i>has-sender-types</i> = <i>see-below</i>; // exposition only</del>

      ...
      template &lt;class E> <ins>// arguments are not associated entities ([lib.tmpl-heads])</ins>
        struct dependent_completion_signatures;

      ...
      template&lt;class S,
              class E = no_env,
              template &lt;class...> class Tuple = <i>decayed-tuple</i>,
              template &lt;class...> class Variant = <i>variant-or-empty</i>>
          requires sender&lt;S, E>
        using value_types_of_t =
          <del>typename completion_signatures_of_t&lt;S, S>::template value_types&lt;Tuple, Variant></del>
          <ins><i>see below</i></ins>;

      template&lt;class S,
              class E = no_env,
              template &lt;class...> class Variant = <i>variant-or-empty</i>>
          requires sender&lt;S, E>
        using error_types_of_t =
          <del>typename completion_signatures_of_t&lt;S, S>::template error_types&lt;Variant></del>
          <ins><i>see below</i></ins>;
      <ins>
      template&lt;class S, class E = no_env>
          requries sender&lt;S, E>
        inline constexpr bool sends_stopped = <i>see below</i>;</ins>

      ...
      // [exec.utils.cmplsigs]
      template &lt;<i>completion-signature</i>... Fns><del> // arguments are not associated entities ([lib.tmpl-heads])</del>
        struct completion_signatures<ins> {}</ins>;

      template &lt;class... Args> <i>// exposition only</i>
        using <i>default-set-value</i> =
          <ins>completion_signatures&lt;</ins>set_value_t(Args...)<ins>></ins>;

      template &lt;class Err> <i>// exposition only</i>
        using <i>default-set-error</i> =
          <ins>completion_signatures&lt;</ins>set_error_t(Err)<ins>></ins>;
      <ins>
      template &lt;class Sigs, class E> // exposition only
        concept <i>valid-completion-signatures</i> = <i>see below</i>;</ins>

      // [exec.utils.mkcmplsigs]
      template <
        sender Sndr,
        class Env = no_env,
        <del>class</del><ins><i>valid-completion-signatures&lt;Env></i></ins> AddlSigs = completion_signatures<>,
        template &lt;class...> class SetValue = <i><del>/* see below */</del><ins>default-set-value</ins></i>,
        template &lt;class> class SetError = <i><del>/* see below */</del><ins>default-set-error</ins></i>,
        <del>bool SendsStopped = completion_signatures_of_t&lt;Sndr, Env>::sends_stopped></del>
        <ins><i>valid-completion-signatures&lt;Env></i> SetStopped = completion_signatures&lt;set_stopped_t()>></ins>
          requires sender<Sndr, Env>
      using make_completion_signatures = completion_signatures<<i>/* see below */</i>>;
    </pre>

## `execution::get_env`

Change [exec.get_env] as follows:

    1. `get_env` is a customization point object. For some subexpression `r`, `get_env(r)` is expression-equivalent to

        1. `tag_invoke(execution::get_env, r)` if that expression is well-formed.

            <ins>
            * <i>Mandates:</i> The decayed type of the above expression is not `no_env`.</ins>

        2. Otherwise, <del><code><i>empty-env</i>{}</code></del><ins>`get_env(r)` is ill-formed</ins>.

## Receivers

In [exec.recv], replace paragraphs 1 and 2 with the following:

<div class="ins">
1. A <i>receiver</i> represents the continuation of an asynchronous operation.
    An asynchronous operation may complete with a (possibly empty) set of
    values, an error, or it may be cancelled. A receiver has three principal
    operations corresponding to the three ways an asynchronous operation may
    complete: `set_value`, `set_error`, and `set_stopped`. These are
    collectively known as a receiver’s <i>completion-signal operations</i>.

2. The `receiver` concept defines the requirements for a receiver type with an
    unknown set of completion signatures. The `receiver_of` concept defines the
    requirements for a receiver type with a known set of completion signatures.

    <pre highlight=c++>
    template&lt;class T>
      concept receiver =
        move_constructible&lt;remove_cvref_t&lt;T>> &&
        constructible_from&lt;remove_cvref_t&lt;T>, T> &&
        requires(const remove_cvref_t&lt;T>& t) {
          execution::get_env(t);
        };

    template &lt;class Signature, class T>
      concept <i>valid-completion-for</i> = <i>// exposition only</i>
        requires (Signature* sig) {
            []&lt;class Ret, class... Args>(Ret(*)(Args...))
                requires nothrow_tag_invocable&lt;Ret, remove_cvref_t&lt;T>, Args...>
            {}(sig);
        };

    template &lt;class T, class Completions>
      concept receiver_of =
        receiver&lt;T> &amp;&amp;
        requires (Completions* completions) {
            []&lt;<i>valid-completion-for</i>&lt;T>...Sigs>(completion_signatures&lt;Sigs...>*)
            {}(completions);
        };
    </pre>
</div>

## `execution::set_value`

Change [exec.set_value] as follows:

1. `execution::set_value` is used to send a <i>value completion signal</i> to a receiver.

2. The name `execution::set_value` denotes a customization point object. The
    expression `execution::set_value(R, Vs...)` for some subexpressions `R` and
    `Vs...` is expression-equivalent to:

    1. `tag_invoke(execution::set_value, R, Vs...)`, if that expression is
        valid. If the function selected by `tag_invoke` does not send the
        value(s) `Vs...` to the receiver `R`’s value channel, the behavior of
        calling `execution::set_value(R, Vs...)` is undefined.

        <ins>
        * <i>Mandates:</i> The `tag_invoke` expression above is not potentially
            throwing.</ins>

    2. Otherwise, `execution::set_value(R, Vs...)` is ill-formed.

## Senders

Change [exec.snd] as follows:

1. A sender describes a potentially asynchronous operation. A sender's responsibility is to fulfill the receiver contract of a connected receiver by delivering one of the receiver completion-signals.

2. The `sender` concept defines the requirements for a sender type. The `sender_to` concept defines the requirements for a sender type capable of being connected with a specific receiver type.

    <pre highlight=c++>
    <div class="del">template&lt;template&lt;template&lt;class...> class, template&lt;class...> class> class>
      struct <i>has-value-types</i>; // exposition only

    template&lt;template&lt;template&lt;class...> class> class>
      struct <i>has-error-types</i>; // exposition only

    template&lt;class S>
      concept <i>has-sender-types</i> = // exposition only
        requires {
          typename <i>has-value-types</i>&lt;S::template value_types>;
          typename <i>has-error-types</i>&lt;S::template error_types>;
          typename bool_constant&lt;S::sends_stopped>;
        };</div>
    <div class="ins">template &lt;class T, template &lt;class...> class C>
      inline constexpr bool <i>is-instance-of</i> = false; // exposition only

    template &lt;class... Ts, template &lt;class...> class C>
      inline constexpr bool <i>is-instance-of</i>&lt;C&lt;Ts...>, C> = true;

    template &lt;class Sigs, class E>
      concept <i>valid-completion-signatures</i> = // exposition only
        <i>is-instance-of</i>&lt;Sigs, completion_signatures> ||
        (
          same_as&lt;Sigs, dependent_completion_signatures&lt;no_env>> &&
          same_as&lt;E, no_env>
        );</div>

    template &lt;class S, class E>
      concept <i>sender-base</i> = // exposition only
        <del>requires { typename completion_signatures_of_t&lt;S, E>; } &amp;&amp;
        <i>has-sender-types</i>&lt;completion_signatures_of_t&lt;S, E>></del>
        <ins>requires (S&& s, E&& e) {
          { get_completion_signatures(std::forward&lt;S>(s), std::forward&lt;E>(e)) } ->
            <i>valid-completion-signatures</i>&lt;E>;
        }</ins>;

    template&lt;class S, class E = no_env>
      concept sender =
        <i>sender-base</i>&lt;S, E> &amp;&amp;
        <i>sender-base</i>&lt;S, no_env> &amp;&amp;
        move_constructible&lt;remove_cvref_t&lt;S>>;

    template&lt;class S, class R>
      concept sender_to =
        sender&lt;S, env_of_t&lt;R>> &amp;&amp;
        <del>receiver&lt;R> &amp;&amp;</del>
        <ins>receiver_of&lt;R, completion_signatures_of_t&lt;S, env_of_t&lt;R>>> &amp;&amp;</ins>
        requires (S&amp;&amp; s, R&amp;&amp; r) {
          execution::connect(std::forward&lt;S>(s), std::forward&lt;R>(r));
        };
    </pre>

3. The `sender_of` concept defines the requirements for a sender type that on successful completion sends the specified set of value types.

    <pre highlight=c++>
    template&ltclass S, class E = no_env, class... Ts>
      concept sender_of =
        sender&ltS, E> &&
        same_as&lt
          <i>type-list</i>&ltTs...>,
          <del>typename completion_signatures_of_t&ltS, E>::template value_types&lt<i>type-list</i>, type_identity_t></del>
          <ins>value_types_of_t&ltS, E, <i>type-list</i>, type_identity_t></ins>
        >;
    </pre>

## `execution::completion_signatures_of_t`

Change [exec.sndtraitst]/p4 as follows:

4. `execution::get_completion_signatures` is a customization point object. Let
    `s` be an expression such that `decltype((s))` is `S`, and let `e` be an
    expression such that `decltype((e))` is `E`. Then
    `get_completion_signatures(s)` is expression-equivalent to
    `get_completion_signatures(s, no_env{})` and `get_completion_signatures(s,
    e)` is expression-equivalent to:

    1. `tag_invoke_result_t<get_completion_signatures_t, S, E>{}` if that expression is well-formed,

        <ins>
        * <i>Mandates:</i> <code><i>is-instance-of</i>&lt;Sigs,
            completion_signatures></code> or <code><i>is-instance-of</i>&lt;Sigs,
            dependent_completion_signatures></code>, where `Sigs` names the type
            `tag_invoke_result_t<get_completion_signatures_t, S, E>`.</ins>

    2. Otherwise, if `remove_cvref_t<S>::completion_signatures` is well-formed
        and names a type, then a <ins>value-initialized</ins> prvalue of <ins>type</ins>
        `remove_cvref_t<S>::completion_signatures`,

        <ins>
        * <i>Mandates:</i> <code><i>is-instance-of</i>&lt;Sigs,
            completion_signatures></code> or <code><i>is-instance-of</i>&lt;Sigs,
            dependent_completion_signatures></code>, where `Sigs` names the type `remove_cvref_t<S>::completion_signatures`.</ins>

    3. Otherwise, [...]

## `dependent_completion_signatures`

Change [exec.depsndtraits] as follows:

<pre highlight="c++">
template &lt;class E>  <ins>// arguments are not associated entities ([lib.tmpl-heads])</ins>
  struct dependent_completion_signatures<ins> {}</ins>;
</pre>

1. `dependent_completion_signatures` is a placeholder completion signatures
    descriptor that can be <del>used</del><ins>returned from `get_completion_signatures`</ins> to report
    that a type might be a sender within a particular execution environment, but
    it isn't a sender in an arbitrary execution environment.

<div class="del">
2. If `decay_t<E>` is `no_env`, `dependent_completion_signatures<E>` is equivalent to:

    <pre highlight="c++">
    template &lt;>
      struct dependent_completion_signatures&lt;no_env> {
        template &lt;template &lt;class...> class, template &lt;class...> class>
            requires false
          using value_types = <i>/* unspecified */</i>;

        template &lt;template &lt;class...> class>
            requires false
          using error_types = <i>/* unspecified */</i>;

        static constexpr bool sends_stopped = <i>/* unspecified */</i>;
      };
    </pre>

    Otherwise, `dependent_completion_signatures<E>` is an empty struct.
</div>

<div class="ins">
2. When used as the return type of a customization of
    `get_completion_signatures`, the template argument `E` shall be the
    unqualified type of the second argument.</div>

## `execution::connect`

Change [exec.connect]/p2 as follows:

2. The name `execution::connect` denotes a customization point object. For some subexpressions `s` and `r`, let `S` be `decltype((s))` and `R` be `decltype((r))`, and let `S'` and `R'` be the decayed types of `S` and `R`, respectively. If `R` does not satisfy `execution::receiver`, `execution::connect(s, r)` is ill-formed. Otherwise, the expression `execution::connect(s, r)` is expression-equivalent to:

    1. `tag_invoke(execution::connect, s, r)`, if <del>that expression is valid and `S` satisfies `execution::sender`</del><ins>the constraints below are satisfied</ins>. If the function selected by `tag_invoke` does not return an operation state for which `execution::start` starts work described by `s`, the behavior of calling `execution::connect(s, r)` is undefined.

          <div class="ins">
          * <i>Constraints:</i>

              <pre highlight="c++">
              sender&lt;S, env_of_t&lt;R>> &amp;&amp;
              receiver_of&lt;R, completion_signatures_of_t&lt;S, env_of_t&lt;R>>> &amp;&amp;
              tag_invocable&lt;connect_t, S, R>
              </pre>
          </div>
          * <i>Mandates:</i> The type of the `tag_invoke` expression above satisfies `operation_state`.

    2. Otherwise, <code><i>connect-awaitable</i>(s, r)</code> if [...]

        [...]

        <div class="del">
        The operand of the <i>requires-clause</i> of <code><i>connect-awaitable</i></code> is equivalent to `receiver_of<R>` if <code><i>await-result-type</i>&lt;S, <i>connect-awaitable-promise</i>></code> is <code><i>cv</i> void</code>; otherwise, it is <code>receiver_of&lt;R, <i>await-result-type</i>&lt;S, <i>connect-awaitable-promise</i>>></code>.</div>

        <div class="ins">
        Let `Res` be <code><i>await-result-type</i>&lt;S, <i>connect-awaitable-promise</i>></code>, and let `Vs...` be an empty parameter pack if `Res` is <code><i>cv</i> void</code>, or a pack containing the single type `Res` otherwise. The operand of the <i>requires-clause</i> of <code><i>connect-awaitable</i></code> is equivalent to `receiver_of<R, Sigs>` where `Sigs` names the type:

            <pre highlight="c++">
            completion_signatures&lt;
              set_value_t(Vs...),
              set_error_t(exception_ptr),
              set_stopped_t()>
            </pre></ins>

    3. Otherwise, `execution::connect(s, r)` is ill-formed.

## `execution::just`

Change [exec.just] as follows:

1. `execution::just` is used to create a sender that propagates a set of values to a connected receiver.

    <pre highlight=c++>
    template&lt;class... Ts>
    struct <i>just-sender</i> <ins>{</ins> // exposition only
      <del>: completion_signatures&lt;set_value_t(Ts...), set_error_t(exception_ptr)> {</del>
      <ins>using completion_signatures =</ins>
        <ins>execution::completion_signatures&lt;set_value_t(Ts...)>;</ins>

      tuple&lt;Ts...> vs_;

      template&lt;class R>
      struct operation_state {
        tuple&lt;Ts...> vs_;
        R r_;

        friend void tag_invoke(start_t, operation_state&amp; s) noexcept {
          <del>try {</del>
            apply([&amp;s](Ts&amp;... values_) {
              set_value(std::move(s.r_), std::move(values_)...);
            }, s.vs_);
          <del>}</del>
          <del>catch (...) {</del>
            <del>set_error(std::move(s.r_), current_exception());</del>
          <del>}</del>
        }
      };

      template&lt;receiver<ins>_of&lt;completion_signatures></ins> R>
        requires <del>receiver_of&lt;R, Ts...> &&</del> (copy_constructible&ltTs> &amp;&amp;...)
      friend operation_state&lt;decay_t<R>> tag_invoke(connect_t, const <i>just-sender</i>&amp; j, R &amp;&amp; r) {
        return { j.vs_, std::forward&lt;R>(r) };
      }

      template&lt;receiver<ins>_of&lt;completion_signatures></ins> R>
        <del>requires receiver_of&lt;R, Ts...></del>
      friend operation_state&lt;decay_t<R>> tag_invoke(connect_t, <i>just-sender</i>&amp;&amp; j, R &amp;&amp; r) {
        return { std::move(j.vs_), std::forward&lt;R>(r) };
      }
    };

    template&lt;<i>movable-value</i>... Ts>
      <i>just-sender</i>&lt;decay_t&lt;Ts>...> just(Ts &amp;&amp;... ts) noexcept(<i>see-below</i>);
    </pre>

1. <i>Effects</i>: [...]

## `execution::just_error`

Change [exec.just_error] as follows:

1. `execution::just_error` is used to create a sender that propagates an error to a connected receiver.

    <pre highlight=c++>
    template&lt;class T>
    struct <i>just-error-sender</i> <ins>{</ins> // exposition only
      <del>: completion_signatures&lt;set_error_t(T)> {</del>
      <ins>using completion_signatures =</ins>
      <ins>  execution::completion_signatures&lt;set_error_t(T)>;</ins>

      T err_;

      template&lt;class R>
      struct operation_state {
        T err_;
        R r_;

        friend void tag_invoke(start_t, operation_state&amp; s) noexcept {
          set_error(std::move(s.r_), std::move(err_));
        }
      };

      template&lt;receiver<ins>_of&lt;completion_signatures></ins> R>
        requires <del>receiver&lt;R, T> &&</del> copy_constructible&lt;T>
      friend operation_state&lt;decay_t&lt;R>> tag_invoke(connect_t, const <i>just-error-sender</i>&amp; j, R&amp;&amp; r) {
        return { j.err_, std::forward&lt;R>(r) };
      }

      template&lt;receiver<ins>_of&lt;completion_signatures></ins> R>
        <del>requires receiver&lt;R, T></del>
      friend operation_state&lt;decay_t&lt;R>> tag_invoke(connect_t, <i>just-error-sender</i>&amp;&amp; j, R&amp;&amp; r) {
        return { std::move(j.err_), std::forward&lt;R>(r) };
      }
    };

    template&lt;<i>movable-value</i> T>
      <i>just-error-sender</i>&lt;decay_t&lt;T>> just_error(T&amp;&amp; t) noexcept(<i>see-below</i>);
    </pre>

1. <i>Effects</i>: [...]


## `execution::just_stopped`

Change [exec.just_stopped] as follows:

1. `execution::just_stopped` is used to create a sender that propagates a stopped signal to a connected receiver.

    <pre highlight=c++>
    struct <i>just-stopped-sender</i> <ins>{</ins> // exposition only
      <del>: completion_signatures&lt;set_stopped_t()> {</del>
      <ins>using completion_signatures =</ins>
      <ins>  execution::completion_signatures&lt;set_stopped_t()>;</ins>

      template&lt;class R>
      struct operation_state {
        R r_;

        friend void tag_invoke(start_t, operation_state&amp; s) noexcept {
          set_stopped(std::move(s.r_));
        }
      };

      template&lt;receiver<ins>_of&lt;completion_signatures></ins> R>
      friend operation_state&lt;decay_t&lt;R>> tag_invoke(connect_t, const <i>just-stopped-sender</i>&amp; j, R&amp;&amp; r) noexcept {
        return { std::forward&lt;R>(r) };
      }
    };

    <i>just-stopped-sender</i> just_stopped() noexcept;
    </pre>

1. <i>Effects</i>: Equivalent to <code><i>just-stopped-sender</i>{}</code>.

## `execution::read`

Change [exec.read]/p3 as follows:

3. <code><i>read-sender</i></code> is an exposition only class template equivalent to:

    <pre highlight=c++>
    template &lt;class Tag>
      struct <i>read-sender</i> { // exposition only
        template&lt;class R>
          struct <i>operation-state</i> { // exposition only
            R r_;

            friend void tag_invoke(start_t, <i>operation-state</i>& s) noexcept try {
              auto value = Tag{}(get_env(s.r_));
              set_value(std::move(s.r_), std::move(value));
            } catch(...) {
              set_error(std::move(s.r_), current_exception());
            }
          };

        <ins>template &lt;class Env></ins>
            <ins>requires <i>callable</i>&lt;Tag, Env></ins>
          <ins>using <i>completions</i> = // exposition only</ins>
            <ins>completion_signatures&lt;</ins>
              <ins>set_value_t(<i>call-result-t</i>&lt;Tag, Env>), set_error_t(exception_ptr)>;</ins>

        <del>template&lt;receiver R></del>
          <del>requires <i>callable</i>&lt;Tag, env_of_t&lt;R>> &amp;&amp;</del>
            <del>receiver_of&lt;R, <i>call-result-t</i>&lt;Tag, env_of_t&lt;R>>></del>
        <ins>template&lt;class R></ins>
          <ins>requires receiver_of&lt;R, <i>completions</i>&lt;env_of_t&lt;R>>></ins>
        friend <i>operation-state</i>&lt;decay_t&lt;R>> tag_invoke(connect_t, <i>read-sender</i>, R && r) {
          return { std::forward&lt;R>(r) };
        }

        <del>friend <i>empty-env</i> tag_invoke(get_completion_signatures_t, <i>read-sender</i>, auto);</del>
        <ins>template&lt;class Env></ins>
          <ins>friend auto tag_invoke(get_completion_signatures_t, <i>read-sender</i>, Env)</ins>
            <ins>-> dependent_completion_signatures&lt;Env>;</ins>

        template&lt;class Env>
          <del>requires (!same_as&lt;Env, no_env>) &amp;&amp; <i>callable</i>&lt;Tag, Env></del>
          friend auto tag_invoke(get_completion_signatures_t, <i>read-sender</i>, Env)
            <del>-> completion_signatures&lt;</del>
                <del>set_value_t(<i>call-result-t</i>&lt;Tag, Env>), set_error_t(exception_ptr)>;</del>
            <ins>-> <i>completions</i>&lt;Env> requires true;</ins>
      };
    </pre>

## `execution::schedule_from`

Replace [exec.schedule_from]/3.3, which begins with "Given an expression `e`, let `E` be `decltype((e))`," with the following:

<div class="ins">
    3. Given subexpressions `s2` and `e`, where `s2` is a sender returned from `schedule_from` or a copy of such, let `S2` be `decltype((s2))` and let `E` be `decltype((e))`. Then the type of `tag_invoke(get_completion_signatures, s2, e)` shall be:

        <pre highlight="c++">
        make_completion_signatures&lt;
          copy_cvref_t&lt;S2, S>,
          E,
          make_completion_signatures&lt;
            schedule_result_t&lt;Sch>,
            E,
            completion_signatures&lt;set_error_t(exception_ptr)>,
            <i>no-value-completions</i>>>;
        </pre>

        where <code><i>no-value-completions</i>&lt;As...></code> names the type `completion_signatures<>`
        for any set of types `As...`.
</div>

## `execution::then`

Replace [exec.then]/p2.3.3, which begins with "Given an expression `e`, let `E` be `decltype((e))`," with the following:

<div class="ins">
        3. Let <code><i>compl-sig-t</i>&lt;Tag, Args...></code> name the type
            `Tag()` if `Args...` is a template paramter pack containing the
            single type `void`; otherwise, `Tag(Args...)`. Given
            subexpressions `s2` and `e` where `s2` is a sender returned from
            `then` or a copy of such, let `S2` be `decltype((s2))` and let
            `E` be `decltype((e))`. The type of
            `tag_invoke(get_completion_signatures, s2, e)` shall be equivalent
            to:

            <pre highlight="c++">
            make_completion_signatures&lt;
              copy_cvref_t&lt;S2, S>, E, <i>set-error-signature</i>,
                <i>set-value-completions</i>>;
            </pre>

            where <code><i>set-value-completions</i></code> is an alias for:

            <pre highlight="c++">
            template &lt;class... As>
              <i>set-value-completions</i> =
                completion_signatures&lt;<i>compl-sig-t</i>&lt;set_value_t, invoke_result_t&lt;F, As...>>>
            </pre>

            and <code><i>set-error-signature</i></code> is an alias for
            `completion_signatures<set_error_t(exception_ptr)>` if any of the types
            in the <code><i>type-list</i></code> named by
            <code>value_types_of_t&lt;copy_cvref_t&lt;S2, S>, E, <i>potentially-throwing</i>, <i>type-list</i>></code>
            are `true_type`; otherwise, `completion_signatures<>`, where
            <code><i>potentially-throwing</i></code> is the template alias:

            <pre highlight="c++">
            template &lt;class... As>
              <i>potentially-throwing</i> =
                bool_constant&lt;is_nothrow_invocable_v&lt;F, As...>>;
            </pre>
</div>

## `execution::upon_error`

Replace [exec.upon_error]/p2.3.3, which begins with "Given an expression `e`, let `E` be `decltype((e))`," with the following:

<div class="ins">
        3. Let <code><i>compl-sig-t</i>&lt;Tag, Args...></code> name the type
            `Tag()` if `Args...` is a template paramter pack containing the
            single type `void`; otherwise, `Tag(Args...)`. Given
            subexpressions `s2` and `e` where `s2` is a sender returned from
            `upon_error` or a copy of such, let `S2` be `decltype((s2))` and let
            `E` be `decltype((e))`. The type of
            `tag_invoke(get_completion_signatures, s2, e)` shall be equivalent
            to:

            <pre highlight="c++">
            make_completion_signatures&lt;
              copy_cvref_t&lt;S2, S>, E, <i>set-error-signature</i>,
                <i>default-set-value</i>, <i>set-error-completion</i>>;
            </pre>

            where <code><i>set-error-completion</i></code> is the template alias:

            <pre highlight="c++">
            template &lt;class E>
              <i>set-error-completion</i> =
                completion_signatures&lt;<i>compl-sig-t</i>&lt;set_value_t, invoke_result_t&lt;F, E>>>
            </pre>

            and <code><i>set-error-signature</i></code> is an alias for
            `completion_signatures<set_error_t(exception_ptr)>` if any of the types
            in the <code><i>type-list</i></code> named by
            <code>error_types_of_t&lt;copy_cvref_t&lt;S2, S>, E, <i>potentially-throwing</i>></code>
            are `true_type`; otherwise, `completion_signatures<>`, where
            <code><i>potentially-throwing</i></code> is the template alias:

            <pre highlight="c++">
            template &lt;class... Es>
              <i>potentially-throwing</i> =
                <i>type-list</i>&lt;bool_constant&lt;is_nothrow_invocable_v&lt;F, Es>>...>;
            </pre>
</div>

## `execution::upon_stopped`

Replace [exec.upon_stopped]/p2.3.3, which begins "Given some expression `e`, let `E` be `decltype((e))`," with the following:

<div class="ins">
        3. Let <code><i>compl-sig-t</i>&lt;Tag, Args...></code> name the type
            `Tag()` if `Args...` is a template paramter pack containing the
            single type `void`; otherwise, `Tag(Args...)`. Given
            subexpressions `s2` and `e` where `s2` is a sender returned from
            `upon_stopped` or a copy of such, let `S2` be `decltype((s2))` and let
            `E` be `decltype((e))`. The type of
            `tag_invoke(get_completion_signatures, s2, e)` shall be equivalent
            to:

            <pre highlight="c++">
            make_completion_signatures&lt;
              copy_cvref_t&lt;S2, S>, E, <i>set-error-signature</i>,
                <i>default-set-value</i>, <i>default-set-error</i>, <i>set-stopped-completions</i>>;
            </pre>

            where <code><i>set-stopped-completions</i></code> names the type
            <code>completion_signatures&lt;<i>compl-sig-t</i>&lt;set_value_t,
            invoke_result_t&lt;F>></code>, and
            <code><i>set-error-signature</i></code> names the type
            `completion_signatures<set_error_t(exception_ptr)>` if
            `is_nothrow_invocable_v<F>` is `true`, or `completion_signatures<>`
            otherwise.
            </pre>
</div>

## `execution::bulk`

Replace [exec.bulk]/p2.4, which begins, "Given an expression `e`, let `E` be `decltype((e))`," with the following:

<div class="ins">
        4. Given subexpressions `s2` and `e` where `s2` is a sender returned
            from `bulk` or a copy of such, let `S2` be `decltype((s2))` and let
            `E` be `decltype((e))`. The type of
            `tag_invoke(get_completion_signatures, s2, e)` shall be equivalent
            to:

            <pre highlight="c++">
            make_completion_signatures&lt;
              copy_cvref_t&lt;S2, S>, E, completion_signatures&lt;set_error_t(exception_ptr)>>
            </pre>
</div>

## `execution::split`

Replace [exec.split]/p3.4, which begins, "Given an expression `e`, let `E` be `decltype((e))`," with the following:

<div class="ins">
        4. Given subexpressions `s2` and `e` where `s2` is a sender returned
            from `split` or a copy of such, let `S2` be `decltype((s2))`
            and let `E` be `decltype((e))`. The type of
            `tag_invoke(get_completion_signatures, s2, e)` shall be equivalent
            to:

            <pre highlight="c++">
            make_completion_signatures&lt;
              copy_cvref_t&lt;S2, S>, E, completion_signatures&lt;set_error_t(exception_ptr)>,
                <i>value-signatures</i>, <i>error-signatures</i>>;
            </pre>

            where <code><i>value-signatures</i></code>
            is the alias template:

            <pre highlight="c++">
            template &lt;class... Ts>
              using <i>value-signatures</i> =
                completion_signatures&lt;set_value_t(decay_t&lt;Ts>&amp;...)>;
            </pre>

            and <code><i>error-signatures</i></code> is the alias template:

            <pre highlight="c++">
            template &lt;class E>
              using <i>error-signatures</i> =
                completion_signatures&lt;set_error_t(decay_t&lt;E>&amp;)>;
            </pre>
</div>

## `execution::when_all`

Replace [exec.when_all]/p2.2.5, which begins, "Given some expression `e`, let `E` be `decltype((e))`," with the following:

<div class="ins">
        5. Given subexpressions `s2` and `e` where `s2` is a sender returned
            from `when_all` or a copy of such, let `S2` be `decltype((s2))`, let
            `E` be `decltype((e))`, and let `Ss...` be the decayed types of the
            arguments to the `when_all` expression that created `s2`. If the
            decayed type of `e` is `no_env`, let `WE` be `no_env`; otherwise,
            let `WE` be a type such that `stop_token_of_t<WE>` is
            `in_place_stop_token` and `tag_invoke_result_t<Tag, WE, As...>`
            names the type, if any, of <code><i>call-result-t</i>&lt;Tag, E,
            As...></code> for all types `As...` and all types `Tag` besides
            `get_stop_token_t`. The type of
            `tag_invoke(get_completion_signatures, s2, e)` shall be as follows:

            1. For each type <code>S<i><sub>i</sub></i></code> in `Ss...`, let
                <code>S'<i><sub>i</sub></i></code> name the type
                <code>copy_cvref_t&lt;S2, S<i><sub>i</sub></i>></code>. If for
                any type <code>S'<i><sub>i</sub></i></code>, the type
                <code>completion_signatures_of_t&lt;S'<i><sub>i</sub></i>,
                WE></code> names a type other than an instantiation of
                `completion_signatures`, the type of
                `tag_invoke(get_completion_signatures, s2, e)` shall be
                `dependent_completion_signatures<E>`.

            2. Otherwise, for each type <code>S'<i><sub>i</sub></i></code>, let
                <code>Sigs<i><sub>i</sub></i>...</code> be the set of template
                arguments in the instantiation of `completion_signatures` named
                by <code>completion_signatures_of_t&lt;S'<i><sub>i</sub></i>,
                WE></code>, and let <code>C<i><sub>i</sub></i></code> be the
                count of function types in
                <code>Sigs<i><sub>i</sub></i>...</code> for which the return
                type is `set_value_t`. If any
                <code>C<i><sub>i</sub></i></code> is two or greater, then the
                type of `tag_invoke(get_completion_signatures, s2, e)` shall be
                `dependent_completion_signatures<E>`.

            3. Otherwise, let <code>Sigs2<i><sub>i</sub></i>...</code> be the set of
                function types in <code>Sigs<i><sub>i</sub></i>...</code> whose
                return types are <i>not</i> `set_value_t`, and let `Ws...` be
                the unique set of types in <code>[Sigs2<i><sub>0</sub></i>...,
                Sigs2<i><sub>1</sub></i>..., ... Sigs2<i><sub>n-1</sub></i>...,
                set_error_t(exception_ptr), set_stopped_t()]</code>, where
                <code><i>n</i></code> is `sizeof...(Ss)`. If any
                <code>C<i><sub>i</sub></i></code> is `0`, then the type of
                `tag_invoke(get_completion_signatures, s2, e)` shall be
                `completion_signatures<Ws...>`.

            4. Otherwise, let <code>V<i><sub>i</sub></i>...</code> be the function
                argument types of the single type in <code>Sigs<i><sub>i</sub></i>...</code>
                for which the return type is `set_value_t`. Then the type of
                `tag_invoke(get_completion_signatures, s2, e)` shall be
                <code>completion_signatures&lt;Ws..., set_value_t(V<i><sub>0</sub></i>...,
                V<i><sub>1</sub></i>..., ... V<i><sub>n-1</sub></i>...)></code>.
</div>

## `execution::ensure_started`

Replace [exec.ensure_started]/p2.4 which begins, "Given an expression `e`, let `E` be `decltype((e))`," with the following:

<div class="ins">
    4. Given subexpressions `s2` and `e` where `s2` is a sender returned
        from `ensure_started` or a copy of such, let `S2` be `decltype((s2))` and let
        `E` be `decltype((e))`. The type of
        `tag_invoke(get_completion_signatures, s2, e)` shall be equivalent
        to:

            <pre highlight="c++">
            make_completion_signatures&lt;
              copy_cvref_t&lt;S2, S>,
              <i>ensure-started-env</i>,
              completion_signatures&lt;set_error_t(exception_ptr&amp;&amp;)>,
              <i>set-value-signature</i>,
              <i>error-types</i>>
            </pre>

            where <code><i>set-value-signature</i></code> is the alias template:

            <pre highlight="c++">
            template &lt;class... Ts>
              using <i>set-value-signature</i> =
                completion_signatures&lt;set_value_t(decay_t&lt;Ts>&amp;&amp;...)>;
            </pre>

            and <code><i>error-types</i></code> is the alias template:

            <pre highlight="c++">
            template &lt;class E>
              using <i>error-types</i> =
                completion_signatures&lt;set_error_t(decay_t&lt;E>&amp;&amp;)>;
            </pre>
</div>

## `execution::start_detached`

Change [exec.start_detached]p2.3 as follows:


    3. Otherwise:

        1. <del>Constructs a receiver `r`</del><ins>Let `R` be the type of a receiver, let `r` be an rvalue of type `R`, and let `cr` be a
            lvalue reference to `const R` such that</ins>:

            1. <del>When `set_value(r, ts...)` is called, it does nothing.</del><ins>The expression `set_value(r)` is not potentially throwing and has no effect,</ins>

            2. <del>When `set_error(r, e)` is called, it calls `std::terminate`.</del><ins>For any subexpression `e`, the expression `set_error(r, e)` is expression-equivalent
                to `terminate()`,</ins>

            3. <del>When `set_stopped(r)` is called, it does nothing.</del><ins>The expression `set_stopped(r)` is not potentially throwing and has no effect, and</ins>

            <ins>
            4. The expression `get_env(cr)` is expression-equivalent to <code><i>empty-env</i>{}</code>.</ins>

        2. Calls `execution::connect(s, r)`, resulting in an operation state
            `op_state`, then calls `execution::start(op_state)`. The lifetime of
            `op_state` lasts until one of the receiver completion-signals of `r`
            is called.

## `this_thread::sync_wait`

Change [exec.sync_wait]/p4.3.3.1 as follows:

            1. If `execution::set_value(r, ts...)` has been called, returns <code><i>sync-wait-type</i>&lt;S, <i>sync-wait-env</i>>{<i>decayed-tuple</i>&lt;decltype(ts)...>{ts...}}</code>. <ins>If that expression exits exceptionally, the exception is propagated to the caller of `sync_wait`.</ins>

## `execution::receiver_adaptor`

Remove [exec.utils.rcvr_adptr]/p2, which begins, "This section makes use of the following exposition-only entities," and renumber all subsequent paragraphs.

Change [exec.utils.rcvr_adptr]/p4-6 (now p3-5) as follows:

3. `receiver_adaptor<Derived, Base>` is equivalent to the following:

    <pre highlight="c++">
    template &lt;
      <i>class-type</i> Derived,
      receiver Base = <i>unspecified</i>> // arguments are not associated entities ([lib.tmpl-heads])
    class receiver_adaptor {
      friend Derived;
     public:
      // Constructors
      receiver_adaptor() = default;
      template &lt;class B>
          requires <i>HAS-BASE</i> && constructible_from&lt;Base, B>
        explicit receiver_adaptor(B&& base) : base_(std::forward&lt;B>(base)) {}

     private:
      using set_value = <i>unspecified</i>;
      using set_error = <i>unspecified</i>;
      using set_stopped = <i>unspecified</i>;
      <ins>using get_env = <i>unspecified</i>;</ins>

      // Member functions
      template &lt;class Self>
        requires <i>HAS-BASE</i>
      <del>copy_cvref_t&lt;Self, Base>&amp;&amp;</del><ins>decltype(auto)</ins> base(this Self&amp;&amp; self) noexcept {
        <del>return static_cast&lt;Self&amp;&amp;>(self).base_;</del>
        <ins>return (std::forward&lt;Self>(self).base_);</ins>
      }

      // [exec.utils.rcvr_adptr.nonmembers] Non-member functions
      template &lt;<del>class D = Derived,</del> class... As>
        friend void tag_invoke(set_value_t, Derived&amp;&amp; self, As&amp;&amp;... as) noexcept<del>(<i>see below</i>)</del>;

      template &lt;class E<del>, class D = Derived</del>>
        friend void tag_invoke(set_error_t, Derived&amp;&amp; self, E&amp;&amp; e) noexcept;

      <del>template &lt;class D = Derived></del>
      friend void tag_invoke(set_stopped_t, Derived&amp;&amp; self) noexcept;
      <ins>
      friend decltype(auto) tag_invoke(get_env_t, const Derived&amp; self)
          noexcept(<i>see below</i>);</ins>

      template &lt;<i>forwarding-receiver-query</i> Tag<del>, class D = Derived</del>, class... As>
          requires <i>callable</i>&lt;Tag, <i>BASE-TYPE</i>(const D<ins>erived</ins>&amp;), As...>
        friend auto tag_invoke(Tag tag, const Derived&amp; self, As&amp;&amp;... as)
          noexcept(<i>nothrow-callable</i>&lt;Tag, <i>BASE-TYPE</i>(const D<ins>erived</ins>&amp;), As...>)
          -> <i>call-result-t</i>&lt;Tag, <i>BASE-TYPE</i>(const D<ins>erived</ins>&), As...> {
          return std::move(tag)(<i>GET-BASE</i>(self), std::forward&lt;As>(as)...);
        }

      [[no_unique_address]] Base base_; // present if and only if <i>HAS-BASE</i> is true
    };
    </pre>

4. [<i>Note:</i> `receiver_adaptor` provides `tag_invoke` overloads on behalf of
    the derived class `Derived`, which is incomplete when `receiver_adaptor` is
    instantiated.]

5. [<i>Example:</i>
     <pre highlight="c++">
     <ins>using _int_completion =</ins>
     <ins>  execution::completion_signatures&lt;execution::set_value_t(int)>;</ins>

     template &lt;execution::receiver_of&lt;<del>int</del><ins>_int_completion</ins>> R>
       class my_receiver : execution::receiver_adaptor&lt;my_receiver&lt;R>, R> {
         friend execution::receiver_adaptor&lt;my_receiver, R>;
         void set_value() && {
           execution::set_value(std::move(*this).base(), 42);
         }
        public:
         using execution::receiver_adaptor&lt;my_receiver, R>::receiver_adaptor;
       };
     </pre>
     -- <i>end example</i>]


Replace section [exec.utils.rcvr_adptr.nonmembers] with the following:

<div class="ins">
    <pre>
    template &lt;class... As>
      friend void tag_invoke(set_value_t, Derived&amp;&amp; self, As&amp;&amp;... as) noexcept;
    </pre>

    1. Let `SET-VALUE` be the expression `std::move(self).set_value(std::forward<As>(as)...)`.

    2. <i>Constraints:</i> Either `SET-VALUE` is a valid expression or `typename Derived::set_value` denotes a type and <code><i>callable</i>&lt;set_value_t, <i>BASE-TYPE</i>(Derived), As...></code> is `true`.

    3. <i>Mandates:</i> `SET-VALUE`, if that expression is valid, is not potentially throwing.

    4. <i>Effects:</i> Equivalent to:

        * If `SET-VALUE` is a valid expression, `SET-VALUE`;

        * Otherwise, <code>execution::set_value(<i>GET-BASE</i>(std::move(self)), std::forward&lt;As>(as)...)</code>.

    <pre>
    template &lt;class E>
      friend void tag_invoke(set_error_t, Derived&amp;&amp; self, E&amp;&amp; e) noexcept;
    </pre>

    1. Let `SET-ERROR` be the expression `std::move(self).set_error(std::forward<E>(e))`.

    2. <i>Constraints:</i> Either `SET-ERROR` is a valid expression or `typename Derived::set_error` denotes a type and <code><i>callable</i>&lt;set_error_t, <i>BASE-TYPE</i>(Derived), E></code> is `true`.

    3. <i>Mandates:</i> `SET-ERROR`, if that expression is valid, is not potentially throwing.

    4. <i>Effects:</i> Equivalent to:

        * If `SET-ERROR` is a valid expression, `SET-ERROR`;

        * Otherwise, <code>execution::set_error(<i>GET-BASE</i>(std::move(self)), std::forward&lt;E>(e))</code>.

    <pre>
    friend void tag_invoke(set_stopped_t, Derived&amp;&amp; self) noexcept;
    </pre>

    1. Let `SET-STOPPED` be the expression `std::move(self).set_stopped()`.

    2. <i>Constraints:</i> Either `SET-STOPPED` is a valid expression or `typename Derived::set_stopped` denotes a type and <code><i>callable</i>&lt;set_stopped_t, <i>BASE-TYPE</i>(Derived)></code> is `true`.

    3. <i>Mandates:</i> `SET-STOPPED`, if that expression is valid, is not potentially throwing.

    4. <i>Effects:</i> Equivalent to:

        * If `SET-STOPPED` is a valid expression, `SET-STOPPED`;

        * Otherwise, <code>execution::set_stopped(<i>GET-BASE</i>(std::move(self)))</code>.

    <pre>
    friend decltype(auto) tag_invoke(get_env_t, const Derived&amp; self)
      noexcept(<i>see below</i>);
    </pre>

    1. <i>Constraints:</i> Either `self.get_env()` is a valid expression or `typename Derived::get_env` denotes a type and <code><i>callable</i>&lt;get_env_t, <i>BASE-TYPE</i>(const Derived&amp;)></code> is `true`.

    2. <i>Effects:</i> Equivalent to:

        * If `self.get_env()` is a valid expression, `self.get_env()`;

        * Otherwise, <code>execution::get_env(<i>GET-BASE</i>(self))</code>.

    3. <i>Remarks:</i> The expression in the `noexcept` clause is:

        * If `self.get_env()` is a valid expression, `noexcept(self.get_env())`;

        * Otherwise, <code>noexcept(execution::get_env(<i>GET-BASE</i>(self)))</code>.
</div>


## `execution::completion_signatures`

Change [exec.utils.cmplsigs] as follows:


1. <del>`completion_signatures` is used to define a type that implements the nested
    `value_types`, `error_types`, and `sends_stopped` members that describe the
    ways a sender completes. Its arguments are a flat list of function types
    that describe the signatures of the receiver's completion-signal operations
    that the sender invokes.</del><br/>
    <ins>`completion_signatures` is used to describe the completion signals of a receiver that
    a sender may invoke. Its template argument list is a list of function types corresponding
    to the signatures of the receiver's completion signals.</ins>

2. [<i>Example:</i>
     <pre highlight="c++">
      class my_sender {
        using completion_signatures =
          execution::completion_signatures&lt;
            execution::set_value_t(),
            execution::set_value_t(int, float),
            execution::set_error_t(exception_ptr),
            execution::set_error_t(error_code),
            execution::set_stopped_t()>;
      };

      <del>// completion_signatures_of_t&lt;my_sender></del>
      <del>//      ::value_types&lt;tuple, variant> names the type:</del>
      <del>//   variant&lt;tuple&lt;>, tuple&lt;int, float>></del>
      <del>//</del>
      <del>// completion_signatures_of_t&lt;my_sender></del>
      <del>//      ::error_types&lt;variant> names the type:</del>
      <del>//   variant&lt;exception_ptr, error_code></del>
      <del>//</del>
      <del>// completion_signatures_of_t&lt;my_sender>::sends_stopped is true</del>
      <ins>// Declares my_sender to be a sender that can complete by calling</ins>
      <ins>// one of the following for a receiver expression R:</ins>
      <ins>//    execution::set_value(R)</ins>
      <ins>//    execution::set_value(R, int{...}, float{...})</ins>
      <ins>//    execution::set_error(R, exception_ptr{...})</ins>
      <ins>//    execution::set_error(R, error_code{...})</ins>
      <ins>//    execution::set_stopped(R)</ins>
     </pre>
     -- <i>end example</i>]

3. This section makes use of the following exposition-only concept:

    <pre highlight="c++">
    template &lt;class Fn>
      concept <i>completion-signature</i> = <i>see below</i>;
    </pre>

    1. A type `Fn` satisfies <code><i>completion-signature</i></code> if it is a function type with one of the following forms:

        * <code>set_value_t(<i>Vs</i>...)</code>, where <code><i>Vs</i></code> is an arbitrary parameter pack.
        * <code>set_error_t(<i>E</i>)</code>, where <code><i>E</i></code> is an arbitrary type.
        * `set_stopped_t()`

    2. Otherwise, `Fn` does not satisfy <code><i>completion-signature</i></code>.

4.  <pre highlight="c++">
    template &lt;<i>completion-signature</i>... Fns> <del> // arguments are not associated entities ([lib.tmpl-heads])</del>
      struct completion_signatures {<ins>};</ins>
        <del>template &lt;template &lt;class...> class Tuple, template &lt;class...> class Variant></del>
          <del>using value_types = <i>see below</i>;</del>
<del></del>
        <del>template &lt;template &lt;class...> class Variant></del>
          <del>using error_types = <i>see below</i>;</del>
<del></del>
        <del>static constexpr bool sends_stopped = <i>see below</i>;</del>
      <del>};</del>
    </pre>

    <div class="del">
        1. Let <code><i>ValueFns</i></code> be a template parameter pack of the function types in `Fns` whose return types are `execution::set_value_t`, and let <code><i>Values<i><sub>n</sub></i></i></code> be a template parameter pack of the function argument types in the <code><i>n</i></code>-th type in <code><i>ValueFns</i></code>. Then, given two variadic templates <code><i>Tuple</i></code> and <code><i>Variant</i></code>, the type <code>completion_signatures&lt;Fns...>::value_types&lt;<i>Tuple</i>, <i>Variant</i>></code> names the type <code><i>Variant</i>&lt;<i>Tuple</i>&lt;<i>Values<i><sub>0</sub></i></i>...>, <i>Tuple</i>&lt;<i>Values<i><sub>1</sub></i></i>...>, ... <i>Tuple</i>&lt;<i>Values<i><sub>m-1</sub></i></i>...>></code>, where <code><i>m</i></code> is the size of the parameter pack <code><i>ValueFns</i></code>.

        2. Let <code><i>ErrorFns</i></code> be a template parameter pack of the function types in `Fns` whose return types are `execution::set_error_t`, and let <code><i>Error<i><sub>n</sub></i></i></code> be the function argument type in the <code><i>n</i></code>-th type in <code><i>ErrorFns</i></code>. Then, given a variadic template <code><i>Variant</i></code>, the type <code>completion_signatures&lt;Fns...>::error_types&lt;<i>Variant</i>></code> names the type <code><i>Variant</i>&lt;<i>Error<i><sub>0</sub></i></i>, <i>Error<i><sub>1</sub></i></i>, ... <i>Error<i><sub>m-1</sub></i></i>></code>, where <code><i>m</i></code> is the size of the parameter pack <code><i>ErrorFns</i></code>.

        3. `completion_signatures<Fns...>::sends_stopped` is `true` if at least one of the types in `Fns` is `execution::set_stopped_t()`; otherwise, `false`.
    </div>

<div class="ins">
5.  <pre highlight="c++">
    template&lt;class S,
            class E = no_env,
            template &lt;class...> class Tuple = <i>decayed-tuple</i>,
            template &lt;class...> class Variant = <i>variant-or-empty</i>>
        requires sender&lt;S, E>
      using value_types_of_t = <i>see below</i>;
    </pre>

    * Let `Fns...` be a template parameter pack of the arguments of the
        `completion_signatures` instantiation named by
        `completion_signatures_of_t<S, E>`, let <code><i>ValueFns</i></code> be a
        template parameter pack of the function types in `Fns` whose return types
        are `execution::set_value_t`, and let
        <code><i>Values<i><sub>n</sub></i></i></code> be a template parameter
        pack of the function argument types in the <code><i>n</i></code>-th type
        in <code><i>ValueFns</i></code>. Then, given two variadic templates
        <code><i>Tuple</i></code> and <code><i>Variant</i></code>, the type
        <code>value_types_of_t&lt;S, E, <i>Tuple</i>, <i>Variant</i>></code>
        names the type
        <code><i>Variant</i>&lt;<i>Tuple</i>&lt;<i>Values<i><sub>0</sub></i></i>...>,
        <i>Tuple</i>&lt;<i>Values<i><sub>1</sub></i></i>...>, ...
        <i>Tuple</i>&lt;<i>Values<i><sub>m-1</sub></i></i>...>></code>, where
        <code><i>m</i></code> is the size of the parameter pack
        <code><i>ValueFns</i></code>.

6.  <pre highlight="c++">
    template&lt;class S,
            class E = no_env,
            template &lt;class...> class Variant = <i>variant-or-empty</i>>
        requires sender&lt;S, E>
      using error_types_of_t = <i>see below</i>;
    </pre>

    * Let `Fns...` be a template parameter pack of the arguments of the
        `completion_signatures` instantiation named by
        `completion_signatures_of_t<S, E>`, let <code><i>ErrorFns</i></code> be a
        template parameter pack of the function types in `Fns` whose return types
        are `execution::set_error_t`, and let
        <code><i>Error<i><sub>n</sub></i></i></code> be the function argument
        type in the <code><i>n</i></code>-th type in
        <code><i>ErrorFns</i></code>. Then, given a variadic template
        <code><i>Variant</i></code>, the type <code>error_types_of_t&lt;S, E,
        <i>Variant</i>></code> names the type
        <code><i>Variant</i>&lt;<i>Error<i><sub>0</sub></i></i>,
        <i>Error<i><sub>1</sub></i></i>, ...
        <i>Error<i><sub>m-1</sub></i></i>></code>, where <code><i>m</i></code> is
        the size of the parameter pack <code><i>ErrorFns</i></code>.

7.  <pre highlight="c++">
    template&lt;class S, class E = no_env>
        requires sender&lt;S, E>
      inline constexpr bool sends_stopped = <i>see below</i>;
    </pre>

    * Let `Fns...` be a template parameter pack of the arguments of the
        `completion_signatures` instantiation named by
        `completion_signatures_of_t<S, E>`. `sends_stopped<S, E>` is `true` if at
        least one of the types in `Fns` is `execution::set_stopped_t()`;
        otherwise, `false`.
</div>



## `execution::make_completion_signatures`

Change [exec.utils.mkcmplsigs] as follows:

1. `make_completion_signatures` is an alias template used to adapt the
    completion signatures of a sender. It takes a sender, and environment, and
    several other template arguments that apply modifications to the sender's
    completion signatures to generate a new instantiation of
    `execution::completion_signatures`.

2. [<i>Example:</i>
    <pre highlight="c++">
    // Given a sender S and an environment Env, adapt a S's completion
    // signatures by lvalue-ref qualifying the values, adding an additional
    // exception_ptr error completion if its not already there, and leaving the
    // other signals alone.
    template &lt;class... Args>
      using my_set_value_t =
        <ins>execution::completion_signatures&lt;</ins>
          execution::set_value_t(add_lvalue_reference_t&lt;Args>...)<ins>></ins>;

    using my_completion_signals =
      execution::make_completion_signatures&lt;
        S, Env,
        execution::completion_signatures&lt;execution::set_error_t(exception_ptr)>,
        my_set_value_t>;
    </pre>
    -- <i>end example</i>]

3. This section makes use of the following exposition-only entities:

    <pre highlight="c++">
    template &lt;class... As>
      using <i>default-set-value</i> =
        <ins>execution::completion_signatures&lt;</ins>execution::set_value_t(As...)<ins>></ins>;

    template &lt;class Err>
      using <i>default-set-error</i> =
        <ins>execution::completion_signatures&lt;</ins>execution::set_error_t(Err)<ins>></ins>;
    </pre>

4.  <pre highlight="c++">
    template &lt;
      execution::sender Sndr,
      class Env = execution::no_env,
      <del>class</del><ins><i>valid-completion-signatures&lt;Env></i></ins> AddlSigs = execution::completion_signatures&lt;>,
      template &lt;class...> class SetValue = <i>default-set-value</i>,
      template &lt;class> class SetError = <i>default-set-error</i>,
      <del>bool SendsStopped = execution::completion_signatures_of_t&lt;Sndr, Env>::sends_stopped></del>
      <ins><i>valid-completion-signatures&lt;Env></i> SetStopped =
          execution::completion_signatures&lt;set_stopped_t()>></ins>
        requires sender&lt;Sndr, Env>
    using make_completion_signatures =
      execution::completion_signatures&lt;<i>/* see below */</i>>;
    </pre>

      *  <del>`AddlSigs` shall name an instantiation of the
        `execution::completion_signatures` class template.</del>
      *  `SetValue` shall name an alias template such that for any template
          parameter pack `As...`, the type `SetValue<As...>` is either ill-formed<del>, `void` or an
        alias for a function type whose return type is `execution::set_value_t`</del><ins>or else <code><i>valid-completion-signatures</i>&lt;SetValue&lt;As...>, E></code>
          is satisfied</ins>.
      *  `SetError` shall name an alias template such that for any type `Err`,
          `SetError<Err>` is either ill-formed<del>, `void` or an alias for a function
        type whose return type is `execution::set_error_t`</del> <ins>or else
          <code><i>valid-completion-signatures</i>&lt;SetError&lt;Err>, E></code>
          is satisfied</ins>.

    <ins>Then:</ins>

        * Let `Vs...` be a pack of the <del>non-`void`</del> types in the <code><i>type-list</i></code> named
            by <code>value_types_of_t&lt;Sndr, Env, SetValue, <i>type-list</i>></code>.

        *  Let `Es...` be a pack of the <del>non-`void`</del> types in the
            <code><i>type-list</i></code> named by <code>error_types_of_t&lt;Sndr, Env,
            <i>error-list</i>></code>, where <code><i>error-list</i></code> is an
            alias template such that <code><i>error-list</i>&lt;Ts...></code> names
            <code><i>type-list</i>&lt;SetError&lt;Ts>...></code>.

        * Let `Ss` <del>be an empty pack if `SendsStopped` is `false`; otherwise, a
        pack containing the single type `execution::set_stopped_t()`</del><ins>name the type `completion_signatures<>` if `sends_stopped<Sndr,
            Env>` is `false`; otherwise, `SetStopped`</ins>.

        <ins>Then:</ins>

        <div class="del">
        7.  Let `MoreSigs...` be a pack of the template arguments of the
            `execution::completion_signatures` instantiation named by `AddlSigs`.
        8.  If any of the above types are ill-formed, then
            `make_completion_signatures<Sndr, Env, AddlSigs, SetValue, SetDone,
            SendsStopped>` is an alias for `dependent_completion_signatures<Env>`.
        9.  Otherwise, `make_completion_signatures<Sndr, Env, AddlSigs, SetValue,
            SetDone, SendsStopped>` names the type `completion_signatures<Sigs...>`
            where `Sigs...` is the unique set of types in `[Vs..., Es..., Ss...,
            MoreSigs...]`.
        </div>


            <div class="ins">
            1. If any of the above types are ill-formed, then
                `make_completion_signatures<Sndr, Env, AddlSigs, SetValue, SetError,
                SetStopped>` is ill-formed,

            2. Otherwise, if any type in `[AddlSigs, Vs..., Es..., Ss]` is not an
                instantiation of `completion_signatures`, then
                `make_completion_signatures<Sndr, Env, AddlSigs, SetValue, SetError,
                SetStopped>` is an alias for `dependent_completion_signatures<no_env>`,

            3. Otherwise, `make_completion_signatures<Sndr, Env, AddlSigs, SetValue,
                SetError, SetStopped>` names the type `completion_signatures<Sigs...>`
                where `Sigs...` is the unique set of types in all the template arguments
                of all the `completion_signatures` instantiations in `[AddlSigs, Vs..., Es..., Ss]`.
            </div>

## `execution::as_awaitable`

Change [exec.as_awaitable]/p1.2.1 as follows:

        1. <code><i>awaitable-receiver</i></code> is equivalent to the following:

            <pre highlight=c++>
            struct <i>awaitable-receiver</i> {
              variant&lt;monostate, result_t, exception_ptr>* result_ptr_;
              coroutine_handle&lt;P> continuation_;
              // ... <i>see below</i>
            };
            </pre>

            Let `r` be an rvalue expression of type <code><i>awaitable-receiver</i></code>,
            let `cr` be a `const` lvalue that refers to `r`, let <del>`v`</del><ins>`vs...`</ins>
            be an <del>expression of type `result_t`</del><ins>arbitrary function parameter
            pack of types `Vs...`</ins>, and let `err` be an arbitrary expression of type `Err`. Then:

              1. <del>If `value_t` is `void`, then `execution::set_value(r)` is expression-equivalent to  `(r.result_ptr_->emplace<1>(), r.continuation_.resume())`; otherwise, `execution::set_value(r, v)` is expression-equivalent to `(r.result_ptr_->emplace<1>(v), r.continuation_.resume())`.</del><br/>
                  <ins>If `constructible_from<result_t, Vs...>` is satisfied, the expression `execution::set_value(r, vs...)` is not potentially throwing and is equivalent to:</ins>

                  <div class="ins"><pre highlight="c++">
                  try {
                    r.result_ptr_->emplace&lt;1>(vs...);
                  } catch(...) {
                    r.result_ptr_->emplace&lt;2>(current_exception());
                  }
                  r.continuation_.resume();
                  </pre></div>

                  <ins>Otherwise, `execution::set_value(r, vs...)` is ill-formed.</ins>

              2. <ins>The expression</ins> `execution::set_error(r, err)` is <ins>not potentially throwing and is</ins> <del>expression-</del>equivalent to <del><code>(r.result_ptr_->emplace&lt;2>(<i>AS_EXCEPT_PTR</i>(err)), r.continuation_.resume())</code>,</del><ins>:</ins>

                  <div class="ins"><pre highlight="c++">
                  r.result_ptr_->emplace&lt;2>(<i>AS_EXCEPT_PTR</i>(err));
                  r.continuation_.resume();
                  </pre></div>

                  where <code><i>AS_EXCEPT_PTR</i>(err)</code> is:

                  1. `err` if `decay_t<Err>` names the same type as `exception_ptr`,

                  2. Otherwise, `make_exception_ptr(system_error(err))` if `decay_t<Err>` names the same type as `error_code`,

                  3. Otherwise, `make_exception_ptr(err)`.

              3. <ins>The expression</ins> `execution::set_stopped(r)` is <ins>not potentially throwing and is</ins> <del>expression-</del>equivalent to
                `static_cast<coroutine_handle<>>(r.continuation_.promise().unhandled_stopped()).resume()`.

              4. `tag_invoke(tag, cr, as...)` is expression-equivalent to `tag(as_const(cr.continuation_.promise()), as...)` for any expression `tag` whose type satisfies <code><i>forwarding-receiver-query</i></code> and for any set of arguments `as...`.


